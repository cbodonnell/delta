package main

import (
	"strings"
	"text/template"
)

// isSliceType returns true if the type is a slice
func isSliceType(typeStr string) bool {
	return strings.HasPrefix(typeStr, "[]")
}

// isMapType returns true if the type is a map
func isMapType(typeStr string) bool {
	return strings.HasPrefix(typeStr, "map[")
}

var templates = template.Must(template.New("file").Funcs(template.FuncMap{
	"isSliceType": isSliceType,
	"isMapType":   isMapType,
}).Parse(`
{{define "file"}}// Code generated by deltagen. DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/cbodonnell/delta"
)

var _ delta.Entity = (*{{.Name}})(nil)

func (e *{{.Name}}) GetID() int64 {
	return e.ID
}

func (e *{{.Name}}) Clone() delta.Entity {
	cp := *e
	{{- range .Fields}}
	{{- if isSliceType .Type}}
	if e.{{.Name}} != nil {
		cp.{{.Name}} = make({{.Type}}, len(e.{{.Name}}))
		copy(cp.{{.Name}}, e.{{.Name}})
	}
	{{- else if isMapType .Type}}
	if e.{{.Name}} != nil {
		cp.{{.Name}} = make({{.Type}})
		for k, v := range e.{{.Name}} {
			cp.{{.Name}}[k] = v
		}
	}
	{{- end}}
	{{- end}}
	return &cp
}

func (e *{{.Name}}) Delta(o delta.Entity) delta.Delta {
	if o == nil {
		return nil
	}
	other, ok := o.(*{{.Name}})
	if !ok {
		return nil // or panic
	}
	d := &{{.Name}}Delta{}
	{{- range .Fields}}
	{{- if isSliceType .Type}}
	if !delta.SlicesEqual(e.{{.Name}}, other.{{.Name}}) {
		if e.{{.Name}} != nil {
			v := make({{.Type}}, len(e.{{.Name}}))
			copy(v, e.{{.Name}})
			d.{{.Name}} = &v
		} else {
			d.{{.Name}} = &{{.Type}}{}
		}
	}
	{{- else if isMapType .Type}}
	if !delta.MapsEqual(e.{{.Name}}, other.{{.Name}}) {
		if e.{{.Name}} != nil {
			v := make({{.Type}})
			for k, val := range e.{{.Name}} {
				v[k] = val
			}
			d.{{.Name}} = &v
		} else {
			v := make({{.Type}})
			d.{{.Name}} = &v
		}
	}
	{{- else}}
	if e.{{.Name}} != other.{{.Name}} {
		v := e.{{.Name}}
		d.{{.Name}} = &v
	}
	{{- end}}
	{{- end}}
	return d
}

func (e *{{.Name}}) ApplyDelta(d delta.Delta) {
	if d == nil {
		return
	}
	dt, ok := d.(*{{.Name}}Delta)
	if !ok {
		return // or panic
	}
	dt.ApplyTo(e)
}

var _ delta.Delta = (*{{.Name}}Delta)(nil)

type {{.Name}}Delta struct {
	{{- range .Fields}}
	{{.Name}} *{{.Type}}
	{{- end}}
}

func (d *{{.Name}}Delta) ApplyTo(e delta.Entity) {
	et, ok := e.(*{{.Name}})
	if !ok {
		return // or panic
	}
	{{- range .Fields}}
	if d.{{.Name}} != nil {
		{{- if isSliceType .Type}}
		if *d.{{.Name}} != nil {
			et.{{.Name}} = make({{.Type}}, len(*d.{{.Name}}))
			copy(et.{{.Name}}, *d.{{.Name}})
		} else {
			et.{{.Name}} = nil
		}
		{{- else if isMapType .Type}}
		if *d.{{.Name}} != nil {
			et.{{.Name}} = make({{.Type}})
			for k, v := range *d.{{.Name}} {
				et.{{.Name}}[k] = v
			}
		} else {
			et.{{.Name}} = nil
		}
		{{- else}}
		et.{{.Name}} = *d.{{.Name}}
		{{- end}}
	}
	{{- end}}
}
{{end}}
`))
