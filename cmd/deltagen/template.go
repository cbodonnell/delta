package main

import (
	"strings"
	"text/template"
)

// isSliceType returns true if the type is a slice
func isSliceType(typeStr string) bool {
	return strings.HasPrefix(typeStr, "[]")
}

// isMapType returns true if the type is a map
func isMapType(typeStr string) bool {
	return strings.HasPrefix(typeStr, "map[")
}

// getSerializeMethod returns the appropriate serialize method name for a type
func getSerializeMethod(typeStr string) string {
	switch typeStr {
	case "bool":
		return "WriteBool"
	case "int8":
		return "WriteInt8"
	case "int16":
		return "WriteInt16"
	case "int32":
		return "WriteInt32"
	case "int64":
		return "WriteInt64"
	case "uint8", "byte":
		return "WriteUint8"
	case "uint16":
		return "WriteUint16"
	case "uint32":
		return "WriteUint32"
	case "uint64":
		return "WriteUint64"
	case "float32":
		return "WriteFloat32"
	case "float64":
		return "WriteFloat64"
	case "string":
		return "WriteString"
	default:
		if strings.HasPrefix(typeStr, "[]byte") {
			return "WriteBytes"
		}
		return "WriteString" // fallback
	}
}

// getDeserializeMethod returns the appropriate deserialize method name for a type
func getDeserializeMethod(typeStr string) string {
	switch typeStr {
	case "bool":
		return "ReadBool"
	case "int8":
		return "ReadInt8"
	case "int16":
		return "ReadInt16"
	case "int32":
		return "ReadInt32"
	case "int64":
		return "ReadInt64"
	case "uint8", "byte":
		return "ReadUint8"
	case "uint16":
		return "ReadUint16"
	case "uint32":
		return "ReadUint32"
	case "uint64":
		return "ReadUint64"
	case "float32":
		return "ReadFloat32"
	case "float64":
		return "ReadFloat64"
	case "string":
		return "ReadString"
	default:
		if strings.HasPrefix(typeStr, "[]byte") {
			return "ReadBytes"
		}
		return "ReadString" // fallback
	}
}

// getSliceElementType extracts the element type from a slice type (e.g., "[]int32" -> "int32")
func getSliceElementType(sliceType string) string {
	if strings.HasPrefix(sliceType, "[]") {
		return sliceType[2:]
	}
	return sliceType
}

// getMapKeyType extracts the key type from a map type (e.g., "map[string]int32" -> "string")
func getMapKeyType(mapType string) string {
	if !strings.HasPrefix(mapType, "map[") {
		return "string"
	}
	// Find the closing bracket for the key type
	start := 4 // after "map["
	bracket := 1
	for i := start; i < len(mapType); i++ {
		switch mapType[i] {
		case '[':
			bracket++
		case ']':
			bracket--
			if bracket == 0 {
				return mapType[start:i]
			}
		}
	}
	return "string"
}

// getMapValueType extracts the value type from a map type (e.g., "map[string]int32" -> "int32")
func getMapValueType(mapType string) string {
	if !strings.HasPrefix(mapType, "map[") {
		return "string"
	}
	// Find the closing bracket for the key type
	start := 4 // after "map["
	bracket := 1
	for i := start; i < len(mapType); i++ {
		switch mapType[i] {
		case '[':
			bracket++
		case ']':
			bracket--
			if bracket == 0 {
				return mapType[i+1:]
			}
		}
	}
	return "string"
}

var templates = template.Must(template.New("file").Funcs(template.FuncMap{
	"isSliceType":          isSliceType,
	"isMapType":            isMapType,
	"getSerializeMethod":   getSerializeMethod,
	"getDeserializeMethod": getDeserializeMethod,
	"getSliceElementType":  getSliceElementType,
	"getMapKeyType":        getMapKeyType,
	"getMapValueType":      getMapValueType,
}).Parse(`
{{define "file"}}// Code generated by deltagen. DO NOT EDIT.
package {{.PackageName}}

import (
	"io"
	"github.com/cbodonnell/delta"
)

var _ delta.Entity = (*{{.Name}})(nil)

func (e *{{.Name}}) GetID() int64 {
	return e.ID
}

func (e *{{.Name}}) Clone() delta.Entity {
	cp := *e
	{{- range .Fields}}
	{{- if isSliceType .Type}}
	if e.{{.Name}} != nil {
		cp.{{.Name}} = make({{.Type}}, len(e.{{.Name}}))
		copy(cp.{{.Name}}, e.{{.Name}})
	}
	{{- else if isMapType .Type}}
	if e.{{.Name}} != nil {
		cp.{{.Name}} = make({{.Type}})
		for k, v := range e.{{.Name}} {
			cp.{{.Name}}[k] = v
		}
	}
	{{- end}}
	{{- end}}
	return &cp
}

func (e *{{.Name}}) Delta(o delta.Entity) delta.Delta {
	if o == nil {
		return nil
	}
	other, ok := o.(*{{.Name}})
	if !ok {
		return nil // or panic
	}
	d := &{{.Name}}Delta{}
	{{- range .Fields}}
	{{- if isSliceType .Type}}
	if !delta.SlicesEqual(e.{{.Name}}, other.{{.Name}}) {
		if e.{{.Name}} != nil {
			v := make({{.Type}}, len(e.{{.Name}}))
			copy(v, e.{{.Name}})
			d.{{.Name}} = &v
		} else {
			d.{{.Name}} = &{{.Type}}{}
		}
	}
	{{- else if isMapType .Type}}
	if !delta.MapsEqual(e.{{.Name}}, other.{{.Name}}) {
		if e.{{.Name}} != nil {
			v := make({{.Type}})
			for k, val := range e.{{.Name}} {
				v[k] = val
			}
			d.{{.Name}} = &v
		} else {
			v := make({{.Type}})
			d.{{.Name}} = &v
		}
	}
	{{- else}}
	if e.{{.Name}} != other.{{.Name}} {
		v := e.{{.Name}}
		d.{{.Name}} = &v
	}
	{{- end}}
	{{- end}}
	return d
}

func (e *{{.Name}}) ApplyDelta(d delta.Delta) {
	if d == nil {
		return
	}
	dt, ok := d.(*{{.Name}}Delta)
	if !ok {
		return // or panic
	}
	dt.ApplyTo(e)
}

var _ delta.Delta = (*{{.Name}}Delta)(nil)

type {{.Name}}Delta struct {
	{{- range .Fields}}
	{{.Name}} *{{.Type}}
	{{- end}}
}

func (d *{{.Name}}Delta) ApplyTo(e delta.Entity) {
	et, ok := e.(*{{.Name}})
	if !ok {
		return // or panic
	}
	{{- range .Fields}}
	if d.{{.Name}} != nil {
		{{- if isSliceType .Type}}
		if *d.{{.Name}} != nil {
			et.{{.Name}} = make({{.Type}}, len(*d.{{.Name}}))
			copy(et.{{.Name}}, *d.{{.Name}})
		} else {
			et.{{.Name}} = nil
		}
		{{- else if isMapType .Type}}
		if *d.{{.Name}} != nil {
			et.{{.Name}} = make({{.Type}})
			for k, v := range *d.{{.Name}} {
				et.{{.Name}}[k] = v
			}
		} else {
			et.{{.Name}} = nil
		}
		{{- else}}
		et.{{.Name}} = *d.{{.Name}}
		{{- end}}
	}
	{{- end}}
}

func (d *{{.Name}}Delta) Serialize(w io.Writer) error {
	bw := delta.NewBinaryWriter(w)
	
	// Write field presence bitmask
	var fieldMask uint64
	{{- range $i, $field := .Fields}}
	if d.{{$field.Name}} != nil {
		fieldMask |= 1 << {{$i}}
	}
	{{- end}}
	if err := bw.WriteUint64(fieldMask); err != nil {
		return err
	}

	// Write field values for present fields
	{{- range $i, $field := .Fields}}
	if d.{{$field.Name}} != nil {
		{{- if isSliceType $field.Type}}
		// Serialize slice
		if err := bw.WriteVarUint32(uint32(len(*d.{{$field.Name}}))); err != nil {
			return err
		}
		for _, item := range *d.{{$field.Name}} {
			{{- $elementType := getSliceElementType $field.Type}}
			{{- $method := getSerializeMethod $elementType}}
			if err := bw.{{$method}}(item); err != nil {
				return err
			}
		}
		{{- else if isMapType $field.Type}}
		// Serialize map
		if err := bw.WriteVarUint32(uint32(len(*d.{{$field.Name}}))); err != nil {
			return err
		}
		for k, v := range *d.{{$field.Name}} {
			{{- $keyType := getMapKeyType $field.Type}}
			{{- $valueType := getMapValueType $field.Type}}
			{{- $keyMethod := getSerializeMethod $keyType}}
			{{- $valueMethod := getSerializeMethod $valueType}}
			if err := bw.{{$keyMethod}}(k); err != nil {
				return err
			}
			if err := bw.{{$valueMethod}}(v); err != nil {
				return err
			}
		}
		{{- else}}
		// Serialize primitive
		{{- $method := getSerializeMethod $field.Type}}
		if err := bw.{{$method}}(*d.{{$field.Name}}); err != nil {
			return err
		}
		{{- end}}
	}
	{{- end}}
	
	return nil
}

func (d *{{.Name}}Delta) Deserialize(r io.Reader) error {
	br := delta.NewBinaryReader(r)
	
	// Read field presence bitmask
	fieldMask, err := br.ReadUint64()
	if err != nil {
		return err
	}

	// Read field values for present fields
	{{- range $i, $field := .Fields}}
	if fieldMask & (1 << {{$i}}) != 0 {
		{{- if isSliceType $field.Type}}
		// Deserialize slice
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		slice := make({{$field.Type}}, length)
		for i := range slice {
			{{- $elementType := getSliceElementType $field.Type}}
			{{- $method := getDeserializeMethod $elementType}}
			item, err := br.{{$method}}()
			if err != nil {
				return err
			}
			slice[i] = item
		}
		d.{{$field.Name}} = &slice
		{{- else if isMapType $field.Type}}
		// Deserialize map
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		m := make({{$field.Type}})
		for i := uint32(0); i < length; i++ {
			{{- $keyType := getMapKeyType $field.Type}}
			{{- $valueType := getMapValueType $field.Type}}
			{{- $keyMethod := getDeserializeMethod $keyType}}
			{{- $valueMethod := getDeserializeMethod $valueType}}
			k, err := br.{{$keyMethod}}()
			if err != nil {
				return err
			}
			v, err := br.{{$valueMethod}}()
			if err != nil {
				return err
			}
			m[k] = v
		}
		d.{{$field.Name}} = &m
		{{- else}}
		// Deserialize primitive
		{{- $method := getDeserializeMethod $field.Type}}
		val, err := br.{{$method}}()
		if err != nil {
			return err
		}
		d.{{$field.Name}} = &val
		{{- end}}
	}
	{{- end}}
	
	return nil
}
{{end}}
`))
