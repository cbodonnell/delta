// Code generated by deltagen. DO NOT EDIT.
package example

import (
	"io"
	"github.com/cbodonnell/delta"
)

var _ delta.Entity = (*GameState)(nil)

func (e *GameState) GetID() int64 {
	return e.ID
}

func (e *GameState) Clone() delta.Entity {
	cp := *e
	if e.Inventory != nil {
		cp.Inventory = make([]string, len(e.Inventory))
		copy(cp.Inventory, e.Inventory)
	}
	if e.Positions != nil {
		cp.Positions = make([]float64, len(e.Positions))
		copy(cp.Positions, e.Positions)
	}
	if e.PlayerIDs != nil {
		cp.PlayerIDs = make([]int64, len(e.PlayerIDs))
		copy(cp.PlayerIDs, e.PlayerIDs)
	}
	if e.Data != nil {
		cp.Data = make([]byte, len(e.Data))
		copy(cp.Data, e.Data)
	}
	if e.PlayerScores != nil {
		cp.PlayerScores = make(map[string]int16)
		for k, v := range e.PlayerScores {
			cp.PlayerScores[k] = v
		}
	}
	if e.ItemCounts != nil {
		cp.ItemCounts = make(map[int8]int32)
		for k, v := range e.ItemCounts {
			cp.ItemCounts[k] = v
		}
	}
	if e.Metadata != nil {
		cp.Metadata = make(map[string]string)
		for k, v := range e.Metadata {
			cp.Metadata[k] = v
		}
	}
	return &cp
}

func (e *GameState) Delta(o delta.Entity) delta.Delta {
	if o == nil {
		return nil
	}
	other, ok := o.(*GameState)
	if !ok {
		return nil // or panic
	}
	d := &GameStateDelta{}
	if e.ID != other.ID {
		v := e.ID
		d.ID = &v
	}
	if e.Round != other.Round {
		v := e.Round
		d.Round = &v
	}
	if e.Score != other.Score {
		v := e.Score
		d.Score = &v
	}
	if e.Lives != other.Lives {
		v := e.Lives
		d.Lives = &v
	}
	if e.MaxHP != other.MaxHP {
		v := e.MaxHP
		d.MaxHP = &v
	}
	if e.X != other.X {
		v := e.X
		d.X = &v
	}
	if e.Y != other.Y {
		v := e.Y
		d.Y = &v
	}
	if e.Speed != other.Speed {
		v := e.Speed
		d.Speed = &v
	}
	if e.PlayerName != other.PlayerName {
		v := e.PlayerName
		d.PlayerName = &v
	}
	if e.IsActive != other.IsActive {
		v := e.IsActive
		d.IsActive = &v
	}
	if !delta.SlicesEqual(e.Inventory, other.Inventory) {
		if e.Inventory != nil {
			v := make([]string, len(e.Inventory))
			copy(v, e.Inventory)
			d.Inventory = &v
		} else {
			d.Inventory = &[]string{}
		}
	}
	if !delta.SlicesEqual(e.Positions, other.Positions) {
		if e.Positions != nil {
			v := make([]float64, len(e.Positions))
			copy(v, e.Positions)
			d.Positions = &v
		} else {
			d.Positions = &[]float64{}
		}
	}
	if !delta.SlicesEqual(e.PlayerIDs, other.PlayerIDs) {
		if e.PlayerIDs != nil {
			v := make([]int64, len(e.PlayerIDs))
			copy(v, e.PlayerIDs)
			d.PlayerIDs = &v
		} else {
			d.PlayerIDs = &[]int64{}
		}
	}
	if !delta.SlicesEqual(e.Data, other.Data) {
		if e.Data != nil {
			v := make([]byte, len(e.Data))
			copy(v, e.Data)
			d.Data = &v
		} else {
			d.Data = &[]byte{}
		}
	}
	if !delta.MapsEqual(e.PlayerScores, other.PlayerScores) {
		if e.PlayerScores != nil {
			v := make(map[string]int16)
			for k, val := range e.PlayerScores {
				v[k] = val
			}
			d.PlayerScores = &v
		} else {
			v := make(map[string]int16)
			d.PlayerScores = &v
		}
	}
	if !delta.MapsEqual(e.ItemCounts, other.ItemCounts) {
		if e.ItemCounts != nil {
			v := make(map[int8]int32)
			for k, val := range e.ItemCounts {
				v[k] = val
			}
			d.ItemCounts = &v
		} else {
			v := make(map[int8]int32)
			d.ItemCounts = &v
		}
	}
	if !delta.MapsEqual(e.Metadata, other.Metadata) {
		if e.Metadata != nil {
			v := make(map[string]string)
			for k, val := range e.Metadata {
				v[k] = val
			}
			d.Metadata = &v
		} else {
			v := make(map[string]string)
			d.Metadata = &v
		}
	}
	return d
}

func (e *GameState) ApplyDelta(d delta.Delta) {
	if d == nil {
		return
	}
	dt, ok := d.(*GameStateDelta)
	if !ok {
		return // or panic
	}
	dt.ApplyTo(e)
}

var _ delta.Delta = (*GameStateDelta)(nil)

type GameStateDelta struct {
	ID *int64
	Round *int16
	Score *int32
	Lives *int8
	MaxHP *uint16
	X *float64
	Y *float64
	Speed *float32
	PlayerName *string
	IsActive *bool
	Inventory *[]string
	Positions *[]float64
	PlayerIDs *[]int64
	Data *[]byte
	PlayerScores *map[string]int16
	ItemCounts *map[int8]int32
	Metadata *map[string]string
}

func (d *GameStateDelta) ApplyTo(e delta.Entity) {
	et, ok := e.(*GameState)
	if !ok {
		return // or panic
	}
	if d.ID != nil {
		et.ID = *d.ID
	}
	if d.Round != nil {
		et.Round = *d.Round
	}
	if d.Score != nil {
		et.Score = *d.Score
	}
	if d.Lives != nil {
		et.Lives = *d.Lives
	}
	if d.MaxHP != nil {
		et.MaxHP = *d.MaxHP
	}
	if d.X != nil {
		et.X = *d.X
	}
	if d.Y != nil {
		et.Y = *d.Y
	}
	if d.Speed != nil {
		et.Speed = *d.Speed
	}
	if d.PlayerName != nil {
		et.PlayerName = *d.PlayerName
	}
	if d.IsActive != nil {
		et.IsActive = *d.IsActive
	}
	if d.Inventory != nil {
		if *d.Inventory != nil {
			et.Inventory = make([]string, len(*d.Inventory))
			copy(et.Inventory, *d.Inventory)
		} else {
			et.Inventory = nil
		}
	}
	if d.Positions != nil {
		if *d.Positions != nil {
			et.Positions = make([]float64, len(*d.Positions))
			copy(et.Positions, *d.Positions)
		} else {
			et.Positions = nil
		}
	}
	if d.PlayerIDs != nil {
		if *d.PlayerIDs != nil {
			et.PlayerIDs = make([]int64, len(*d.PlayerIDs))
			copy(et.PlayerIDs, *d.PlayerIDs)
		} else {
			et.PlayerIDs = nil
		}
	}
	if d.Data != nil {
		if *d.Data != nil {
			et.Data = make([]byte, len(*d.Data))
			copy(et.Data, *d.Data)
		} else {
			et.Data = nil
		}
	}
	if d.PlayerScores != nil {
		if *d.PlayerScores != nil {
			et.PlayerScores = make(map[string]int16)
			for k, v := range *d.PlayerScores {
				et.PlayerScores[k] = v
			}
		} else {
			et.PlayerScores = nil
		}
	}
	if d.ItemCounts != nil {
		if *d.ItemCounts != nil {
			et.ItemCounts = make(map[int8]int32)
			for k, v := range *d.ItemCounts {
				et.ItemCounts[k] = v
			}
		} else {
			et.ItemCounts = nil
		}
	}
	if d.Metadata != nil {
		if *d.Metadata != nil {
			et.Metadata = make(map[string]string)
			for k, v := range *d.Metadata {
				et.Metadata[k] = v
			}
		} else {
			et.Metadata = nil
		}
	}
}

func (d *GameStateDelta) Serialize(w io.Writer) error {
	bw := delta.NewBinaryWriter(w)
	
	// Write field presence bitmask
	var fieldMask uint64
	if d.ID != nil {
		fieldMask |= 1 << 0
	}
	if d.Round != nil {
		fieldMask |= 1 << 1
	}
	if d.Score != nil {
		fieldMask |= 1 << 2
	}
	if d.Lives != nil {
		fieldMask |= 1 << 3
	}
	if d.MaxHP != nil {
		fieldMask |= 1 << 4
	}
	if d.X != nil {
		fieldMask |= 1 << 5
	}
	if d.Y != nil {
		fieldMask |= 1 << 6
	}
	if d.Speed != nil {
		fieldMask |= 1 << 7
	}
	if d.PlayerName != nil {
		fieldMask |= 1 << 8
	}
	if d.IsActive != nil {
		fieldMask |= 1 << 9
	}
	if d.Inventory != nil {
		fieldMask |= 1 << 10
	}
	if d.Positions != nil {
		fieldMask |= 1 << 11
	}
	if d.PlayerIDs != nil {
		fieldMask |= 1 << 12
	}
	if d.Data != nil {
		fieldMask |= 1 << 13
	}
	if d.PlayerScores != nil {
		fieldMask |= 1 << 14
	}
	if d.ItemCounts != nil {
		fieldMask |= 1 << 15
	}
	if d.Metadata != nil {
		fieldMask |= 1 << 16
	}
	if err := bw.WriteUint64(fieldMask); err != nil {
		return err
	}

	// Write field values for present fields
	if d.ID != nil {
		// Serialize primitive
		if err := bw.WriteInt64(*d.ID); err != nil {
			return err
		}
	}
	if d.Round != nil {
		// Serialize primitive
		if err := bw.WriteInt16(*d.Round); err != nil {
			return err
		}
	}
	if d.Score != nil {
		// Serialize primitive
		if err := bw.WriteInt32(*d.Score); err != nil {
			return err
		}
	}
	if d.Lives != nil {
		// Serialize primitive
		if err := bw.WriteInt8(*d.Lives); err != nil {
			return err
		}
	}
	if d.MaxHP != nil {
		// Serialize primitive
		if err := bw.WriteUint16(*d.MaxHP); err != nil {
			return err
		}
	}
	if d.X != nil {
		// Serialize primitive
		if err := bw.WriteFloat64(*d.X); err != nil {
			return err
		}
	}
	if d.Y != nil {
		// Serialize primitive
		if err := bw.WriteFloat64(*d.Y); err != nil {
			return err
		}
	}
	if d.Speed != nil {
		// Serialize primitive
		if err := bw.WriteFloat32(*d.Speed); err != nil {
			return err
		}
	}
	if d.PlayerName != nil {
		// Serialize primitive
		if err := bw.WriteString(*d.PlayerName); err != nil {
			return err
		}
	}
	if d.IsActive != nil {
		// Serialize primitive
		if err := bw.WriteBool(*d.IsActive); err != nil {
			return err
		}
	}
	if d.Inventory != nil {
		// Serialize slice
		if err := bw.WriteVarUint32(uint32(len(*d.Inventory))); err != nil {
			return err
		}
		for _, item := range *d.Inventory {
			if err := bw.WriteString(item); err != nil {
				return err
			}
		}
	}
	if d.Positions != nil {
		// Serialize slice
		if err := bw.WriteVarUint32(uint32(len(*d.Positions))); err != nil {
			return err
		}
		for _, item := range *d.Positions {
			if err := bw.WriteFloat64(item); err != nil {
				return err
			}
		}
	}
	if d.PlayerIDs != nil {
		// Serialize slice
		if err := bw.WriteVarUint32(uint32(len(*d.PlayerIDs))); err != nil {
			return err
		}
		for _, item := range *d.PlayerIDs {
			if err := bw.WriteInt64(item); err != nil {
				return err
			}
		}
	}
	if d.Data != nil {
		// Serialize slice
		if err := bw.WriteVarUint32(uint32(len(*d.Data))); err != nil {
			return err
		}
		for _, item := range *d.Data {
			if err := bw.WriteUint8(item); err != nil {
				return err
			}
		}
	}
	if d.PlayerScores != nil {
		// Serialize map
		if err := bw.WriteVarUint32(uint32(len(*d.PlayerScores))); err != nil {
			return err
		}
		for k, v := range *d.PlayerScores {
			if err := bw.WriteString(k); err != nil {
				return err
			}
			if err := bw.WriteInt16(v); err != nil {
				return err
			}
		}
	}
	if d.ItemCounts != nil {
		// Serialize map
		if err := bw.WriteVarUint32(uint32(len(*d.ItemCounts))); err != nil {
			return err
		}
		for k, v := range *d.ItemCounts {
			if err := bw.WriteInt8(k); err != nil {
				return err
			}
			if err := bw.WriteInt32(v); err != nil {
				return err
			}
		}
	}
	if d.Metadata != nil {
		// Serialize map
		if err := bw.WriteVarUint32(uint32(len(*d.Metadata))); err != nil {
			return err
		}
		for k, v := range *d.Metadata {
			if err := bw.WriteString(k); err != nil {
				return err
			}
			if err := bw.WriteString(v); err != nil {
				return err
			}
		}
	}
	
	return nil
}

func (d *GameStateDelta) Deserialize(r io.Reader) error {
	br := delta.NewBinaryReader(r)
	
	// Read field presence bitmask
	fieldMask, err := br.ReadUint64()
	if err != nil {
		return err
	}

	// Read field values for present fields
	if fieldMask & (1 << 0) != 0 {
		// Deserialize primitive
		val, err := br.ReadInt64()
		if err != nil {
			return err
		}
		d.ID = &val
	}
	if fieldMask & (1 << 1) != 0 {
		// Deserialize primitive
		val, err := br.ReadInt16()
		if err != nil {
			return err
		}
		d.Round = &val
	}
	if fieldMask & (1 << 2) != 0 {
		// Deserialize primitive
		val, err := br.ReadInt32()
		if err != nil {
			return err
		}
		d.Score = &val
	}
	if fieldMask & (1 << 3) != 0 {
		// Deserialize primitive
		val, err := br.ReadInt8()
		if err != nil {
			return err
		}
		d.Lives = &val
	}
	if fieldMask & (1 << 4) != 0 {
		// Deserialize primitive
		val, err := br.ReadUint16()
		if err != nil {
			return err
		}
		d.MaxHP = &val
	}
	if fieldMask & (1 << 5) != 0 {
		// Deserialize primitive
		val, err := br.ReadFloat64()
		if err != nil {
			return err
		}
		d.X = &val
	}
	if fieldMask & (1 << 6) != 0 {
		// Deserialize primitive
		val, err := br.ReadFloat64()
		if err != nil {
			return err
		}
		d.Y = &val
	}
	if fieldMask & (1 << 7) != 0 {
		// Deserialize primitive
		val, err := br.ReadFloat32()
		if err != nil {
			return err
		}
		d.Speed = &val
	}
	if fieldMask & (1 << 8) != 0 {
		// Deserialize primitive
		val, err := br.ReadString()
		if err != nil {
			return err
		}
		d.PlayerName = &val
	}
	if fieldMask & (1 << 9) != 0 {
		// Deserialize primitive
		val, err := br.ReadBool()
		if err != nil {
			return err
		}
		d.IsActive = &val
	}
	if fieldMask & (1 << 10) != 0 {
		// Deserialize slice
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		slice := make([]string, length)
		for i := range slice {
			item, err := br.ReadString()
			if err != nil {
				return err
			}
			slice[i] = item
		}
		d.Inventory = &slice
	}
	if fieldMask & (1 << 11) != 0 {
		// Deserialize slice
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		slice := make([]float64, length)
		for i := range slice {
			item, err := br.ReadFloat64()
			if err != nil {
				return err
			}
			slice[i] = item
		}
		d.Positions = &slice
	}
	if fieldMask & (1 << 12) != 0 {
		// Deserialize slice
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		slice := make([]int64, length)
		for i := range slice {
			item, err := br.ReadInt64()
			if err != nil {
				return err
			}
			slice[i] = item
		}
		d.PlayerIDs = &slice
	}
	if fieldMask & (1 << 13) != 0 {
		// Deserialize slice
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		slice := make([]byte, length)
		for i := range slice {
			item, err := br.ReadUint8()
			if err != nil {
				return err
			}
			slice[i] = item
		}
		d.Data = &slice
	}
	if fieldMask & (1 << 14) != 0 {
		// Deserialize map
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		m := make(map[string]int16)
		for i := uint32(0); i < length; i++ {
			k, err := br.ReadString()
			if err != nil {
				return err
			}
			v, err := br.ReadInt16()
			if err != nil {
				return err
			}
			m[k] = v
		}
		d.PlayerScores = &m
	}
	if fieldMask & (1 << 15) != 0 {
		// Deserialize map
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		m := make(map[int8]int32)
		for i := uint32(0); i < length; i++ {
			k, err := br.ReadInt8()
			if err != nil {
				return err
			}
			v, err := br.ReadInt32()
			if err != nil {
				return err
			}
			m[k] = v
		}
		d.ItemCounts = &m
	}
	if fieldMask & (1 << 16) != 0 {
		// Deserialize map
		length, err := br.ReadVarUint32()
		if err != nil {
			return err
		}
		m := make(map[string]string)
		for i := uint32(0); i < length; i++ {
			k, err := br.ReadString()
			if err != nil {
				return err
			}
			v, err := br.ReadString()
			if err != nil {
				return err
			}
			m[k] = v
		}
		d.Metadata = &m
	}
	
	return nil
}
