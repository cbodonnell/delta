// Code generated by deltagen. DO NOT EDIT.
package example

import (
	"github.com/cbodonnell/delta"
)

var _ delta.Entity = (*GameState)(nil)

func (e *GameState) GetID() int64 {
	return e.ID
}

func (e *GameState) Clone() delta.Entity {
	cp := *e
	if e.Inventory != nil {
		cp.Inventory = make([]string, len(e.Inventory))
		copy(cp.Inventory, e.Inventory)
	}
	if e.Positions != nil {
		cp.Positions = make([]float64, len(e.Positions))
		copy(cp.Positions, e.Positions)
	}
	if e.PlayerIDs != nil {
		cp.PlayerIDs = make([]int64, len(e.PlayerIDs))
		copy(cp.PlayerIDs, e.PlayerIDs)
	}
	if e.Data != nil {
		cp.Data = make([]byte, len(e.Data))
		copy(cp.Data, e.Data)
	}
	if e.PlayerScores != nil {
		cp.PlayerScores = make(map[string]int)
		for k, v := range e.PlayerScores {
			cp.PlayerScores[k] = v
		}
	}
	if e.ItemCounts != nil {
		cp.ItemCounts = make(map[int]int)
		for k, v := range e.ItemCounts {
			cp.ItemCounts[k] = v
		}
	}
	if e.Metadata != nil {
		cp.Metadata = make(map[string]string)
		for k, v := range e.Metadata {
			cp.Metadata[k] = v
		}
	}
	return &cp
}

func (e *GameState) Delta(o delta.Entity) delta.Delta {
	if o == nil {
		return nil
	}
	other, ok := o.(*GameState)
	if !ok {
		return nil // or panic
	}
	d := &GameStateDelta{}
	if e.ID != other.ID {
		v := e.ID
		d.ID = &v
	}
	if e.Round != other.Round {
		v := e.Round
		d.Round = &v
	}
	if e.Score != other.Score {
		v := e.Score
		d.Score = &v
	}
	if e.Lives != other.Lives {
		v := e.Lives
		d.Lives = &v
	}
	if e.MaxHP != other.MaxHP {
		v := e.MaxHP
		d.MaxHP = &v
	}
	if e.X != other.X {
		v := e.X
		d.X = &v
	}
	if e.Y != other.Y {
		v := e.Y
		d.Y = &v
	}
	if e.Speed != other.Speed {
		v := e.Speed
		d.Speed = &v
	}
	if e.PlayerName != other.PlayerName {
		v := e.PlayerName
		d.PlayerName = &v
	}
	if e.IsActive != other.IsActive {
		v := e.IsActive
		d.IsActive = &v
	}
	if !delta.SlicesEqual(e.Inventory, other.Inventory) {
		if e.Inventory != nil {
			v := make([]string, len(e.Inventory))
			copy(v, e.Inventory)
			d.Inventory = &v
		} else {
			d.Inventory = &[]string{}
		}
	}
	if !delta.SlicesEqual(e.Positions, other.Positions) {
		if e.Positions != nil {
			v := make([]float64, len(e.Positions))
			copy(v, e.Positions)
			d.Positions = &v
		} else {
			d.Positions = &[]float64{}
		}
	}
	if !delta.SlicesEqual(e.PlayerIDs, other.PlayerIDs) {
		if e.PlayerIDs != nil {
			v := make([]int64, len(e.PlayerIDs))
			copy(v, e.PlayerIDs)
			d.PlayerIDs = &v
		} else {
			d.PlayerIDs = &[]int64{}
		}
	}
	if !delta.SlicesEqual(e.Data, other.Data) {
		if e.Data != nil {
			v := make([]byte, len(e.Data))
			copy(v, e.Data)
			d.Data = &v
		} else {
			d.Data = &[]byte{}
		}
	}
	if !delta.MapsEqual(e.PlayerScores, other.PlayerScores) {
		if e.PlayerScores != nil {
			v := make(map[string]int)
			for k, val := range e.PlayerScores {
				v[k] = val
			}
			d.PlayerScores = &v
		} else {
			v := make(map[string]int)
			d.PlayerScores = &v
		}
	}
	if !delta.MapsEqual(e.ItemCounts, other.ItemCounts) {
		if e.ItemCounts != nil {
			v := make(map[int]int)
			for k, val := range e.ItemCounts {
				v[k] = val
			}
			d.ItemCounts = &v
		} else {
			v := make(map[int]int)
			d.ItemCounts = &v
		}
	}
	if !delta.MapsEqual(e.Metadata, other.Metadata) {
		if e.Metadata != nil {
			v := make(map[string]string)
			for k, val := range e.Metadata {
				v[k] = val
			}
			d.Metadata = &v
		} else {
			v := make(map[string]string)
			d.Metadata = &v
		}
	}
	return d
}

func (e *GameState) ApplyDelta(d delta.Delta) {
	if d == nil {
		return
	}
	dt, ok := d.(*GameStateDelta)
	if !ok {
		return // or panic
	}
	dt.ApplyTo(e)
}

var _ delta.Delta = (*GameStateDelta)(nil)

type GameStateDelta struct {
	ID *int64
	Round *int32
	Score *int
	Lives *int8
	MaxHP *uint16
	X *float64
	Y *float64
	Speed *float32
	PlayerName *string
	IsActive *bool
	Inventory *[]string
	Positions *[]float64
	PlayerIDs *[]int64
	Data *[]byte
	PlayerScores *map[string]int
	ItemCounts *map[int]int
	Metadata *map[string]string
}

func (d *GameStateDelta) ApplyTo(e delta.Entity) {
	et, ok := e.(*GameState)
	if !ok {
		return // or panic
	}
	if d.ID != nil {
		et.ID = *d.ID
	}
	if d.Round != nil {
		et.Round = *d.Round
	}
	if d.Score != nil {
		et.Score = *d.Score
	}
	if d.Lives != nil {
		et.Lives = *d.Lives
	}
	if d.MaxHP != nil {
		et.MaxHP = *d.MaxHP
	}
	if d.X != nil {
		et.X = *d.X
	}
	if d.Y != nil {
		et.Y = *d.Y
	}
	if d.Speed != nil {
		et.Speed = *d.Speed
	}
	if d.PlayerName != nil {
		et.PlayerName = *d.PlayerName
	}
	if d.IsActive != nil {
		et.IsActive = *d.IsActive
	}
	if d.Inventory != nil {
		if *d.Inventory != nil {
			et.Inventory = make([]string, len(*d.Inventory))
			copy(et.Inventory, *d.Inventory)
		} else {
			et.Inventory = nil
		}
	}
	if d.Positions != nil {
		if *d.Positions != nil {
			et.Positions = make([]float64, len(*d.Positions))
			copy(et.Positions, *d.Positions)
		} else {
			et.Positions = nil
		}
	}
	if d.PlayerIDs != nil {
		if *d.PlayerIDs != nil {
			et.PlayerIDs = make([]int64, len(*d.PlayerIDs))
			copy(et.PlayerIDs, *d.PlayerIDs)
		} else {
			et.PlayerIDs = nil
		}
	}
	if d.Data != nil {
		if *d.Data != nil {
			et.Data = make([]byte, len(*d.Data))
			copy(et.Data, *d.Data)
		} else {
			et.Data = nil
		}
	}
	if d.PlayerScores != nil {
		if *d.PlayerScores != nil {
			et.PlayerScores = make(map[string]int)
			for k, v := range *d.PlayerScores {
				et.PlayerScores[k] = v
			}
		} else {
			et.PlayerScores = nil
		}
	}
	if d.ItemCounts != nil {
		if *d.ItemCounts != nil {
			et.ItemCounts = make(map[int]int)
			for k, v := range *d.ItemCounts {
				et.ItemCounts[k] = v
			}
		} else {
			et.ItemCounts = nil
		}
	}
	if d.Metadata != nil {
		if *d.Metadata != nil {
			et.Metadata = make(map[string]string)
			for k, v := range *d.Metadata {
				et.Metadata[k] = v
			}
		} else {
			et.Metadata = nil
		}
	}
}
